import express from 'express';
import db from './models/index.js';
import productRoutes from './routes/product.routes.js';
import salesRoutes from './routes/sales.routes.js';
import storeRoutes from './routes/store.routes.js';
import logisticsRoutes from './routes/logistics.routes.js';
import reportRoutes from './routes/report.routes.js';
import swaggerUi from 'swagger-ui-express';
import swaggerSpec from './swagger.js';
import cors from 'cors';

const TOKEN = "token-test"

const app = express();

app.use(cors({
  origin: 'http://localhost:3001',
  methods: ['GET', 'POST', 'PUT', 'DELETE'],
  credentials: true,
}));

app.use(express.json());

app.use('/api', authMiddleware);

app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
app.use('/api/products', productRoutes);
app.use('/api/sales', salesRoutes);
app.use('/api/stores', storeRoutes);
app.use('/api/logistics', logisticsRoutes);
app.use('/api/reports', reportRoutes);

function authMiddleware(req, res, next) {
  const authHeader = req.headers['authorization'];
  
  if (authHeader && authHeader === `Bearer ${TOKEN}`) {
    return next();
  }

  return res.status(401).json({ error: 'Unauthorized' });
}

//This method is generated by AI and is used to wait for the database connection to be established before starting the server.
async function waitForDatabase(sequelize, retries = 10, delay = 3000) {
  for (let i = 0; i < retries; i++) {
    try {
      await sequelize.authenticate();
      console.log('Database is ready');
      return;
    } catch (err) {
      console.error(`Database connection failed: ${err.message}`);
      console.log(`Waiting for DB... (${i + 1}/${retries})`);
      await new Promise((res) => setTimeout(res, delay));
    }
  }
  throw new Error('Could not connect to the database');
}

try {
  await waitForDatabase(db.sequelize);
  await db.sequelize.sync({ force: false });

  app.listen(3000, () => {
    console.log('Server is running at http://localhost:3001');
  });
} catch (err) {
  console.error('Server startup failed:', err);
  process.exit(1);
}

